---
layout: article
title: Iterated function systems
---

As I explained in my second post about working here in Hong Kong, I'm supposed to be tackling this sort of reverse engineering problem - we know how to generate images of fractals given a set of functions, can we determine what the functions were if we are only given the image?

Since all of this was quite new to me, before starting the reverse engineering I first needed to understand the forwards-engineering. I have now been honing my understanding of that process (and writing a program to generate images using those methods) for a couple weeks. It's time to move on. Before I do that, I'd like to sum up what I've learned and also show off the neat little program I've written for visualising this stuff.

This is that.

> Note: stylistically, while I hope to not be completely dry and dull, this _is_ intended as somewhat of a reference document for the problem I'm working on. Meaning: if you're waiting for the bit where this turns into an anecdote from my travels (as if I'd comment on what being on Hong Kong is actually like instead of just supplying the occasional photo and writing about pretty much anything else) or another personal take on a pop culture reference, then sorry you won't find that here. Nevertheless, the problem's pretty neat and I think if you can see the big picture behind all the details (which I will do my best to illuminate) then I think it's well worth sitting down and seeing how it all comes together.

# Terminology - What's a [thing]?
## (Affine) Transformations

So in this context a transformation is a rule that tells us how to move around different points based on their position.

A rule that says 'all points move to the position $(4,3)$' is a perfectly good example of a transformation.

A rule that says 'multiply the $x$ coordinate by two' is also a perfectly good transformation.

They can be as simple or as complex as you like, so long as the definition is unambiguous for every input position.

Although this definition talks all about individual points, we can also talk about transformations in terms of shapes and regions. Let's say the transformation rule was _'add five to the $x$ coordinate of the input point'_. Then take a triangle in the input space, and consider where all the points in that triangle end up if you apply this transformation: The whole triangle shifts five units along to the right!

The way that a transformation _transforms_ one region into another is what makes them a natural language for describing fractal images. Not just any transformation will do though. Transformation that completely mangles any input region into something unrecognisable will not be much use for describing fractal _self similarity_. It is for that reason that we consider a only one particular type of transforms: affine transformations. Named so because output regions share an affinity with their corresponding input regions - perfect for our purpose.

You can think of affine transformations as encompassing all of: shifting, scaling (not necessarily by the same amount in each direction), and rotating. Mathematically speaking, they are given by the composition of a linear transformation and a translation:

<!-- TODO: it would be cool to add a little interactive thing that lets you select input region and output region and see how the resulting affine transformation maps points/regions/looks as represented with a matrix and translation vector -->

$$
f(\,\underline{x}\,)=\color{lightgreen}{\begin{bmatrix}a & b \\ c & d\end{bmatrix}}\begin{bmatrix}x\\y\end{bmatrix} + \color{orange}{\begin{bmatrix}e \\ f\end{bmatrix}}
$$

Where the light green matrix is the linear part of the composition, and the orange vector is the translation vector.

## Descriptions / Instructions

So we have decided that affine transformations will be the language of choice for describing these self similar images. Given an image that contains sub regions which have an affinity to the _overall_ form present in the image, we can describe that affinity with the affine transformation that maps the greater region onto the lesser one.

The problem here is this: we don't want to just describe these images, we want to know how to bring them into existence. Sure, if you already have this self similar shape in front of you then it is possible to draw boxes around the parts which look like copies of the whole, and confirm that the transformation defined in this way do indeed produce smaller and smaller self similar copies - but how was that original image produced? There is a sort of circularity here - using the generated image to confirm the relevance of the transformations. To produce one of these images yourself, you must start out with a blank page. How is it that these transformations conjure _from nothing_ such intricately detailed images - or any images at all? This is an issue quite apart from the question of _describing_ the self similarity, or so it seems.

Rather than jumping right to the explanation, I will show you the method first. I think the fact that this technique actually works (and so well) is somewhat miraculous - It's nice to just see it in action and marvel at it for a moment before moving on.


